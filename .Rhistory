<<<<<<< Updated upstream
=======
gamma = c(0.5, 1, 2, 3, 4)))
summary(tune_out_bs1)
bestmod_bs1 = tune_out_bs1$best.model
summary(bestmod_bs1)
# CM on Training Set
newpred_bs_train1 = predict(bestmod_bs1, train_bs)
confusionMatrix(table(prediction = newpred_bs_train1,
actual = train_bs$default))
# CM on Test Set
newpred_bs_test1 = predict(bestmod_bs1, test_bs)
confusionMatrix(table(prediction = newpred_bs_test1,
actual = test_bs$default))
svm_bs2 = svm(default ~ .,
data = train_bs,
kernel = 'sigmoid',
gamma = 1,
cost = 1)
summary(svm_bs2)
# Tuning of SVM Kernel
set.seed(111)
tune_out_bs2 = tune(svm,
default ~ .,
data = train_bs,
kernel = 'sigmoid',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)))
summary(tune_out_bs2)
bestmod_bs2 = tune_out_bs2$best.model
summary(bestmod_bs2)
# CM on Training Set
newpred_bs_train2 = predict(bestmod_bs2, train_bs)
confusionMatrix(table(prediction = newpred_bs_train2,
actual = train_bs$default))
# CM on Test Set
newpred_bs_test2 = predict(bestmod_bs2, test_bs)
confusionMatrix(table(prediction = newpred_bs_test2,
actual = test_bs$default))
library(ISLR)
library(e1071)
library(caret)
library(caTools)
data(Default)
summary(Default)
# Data import
diabetes = read.csv('./datasets/Diabetes.csv', header = F)
colnames(diabetes) = c('no.of.times.preg', 'plasma.glucose.conc', 'diastolic.pressure',
'triceps.skin.fold.thick', 'serum.insulin', 'bmi', 'diab.pedigree.func',
'age', 'positive.test')
# Factorizing class variable
diabetes$positive.test = as.factor(as.character(diabetes$positive.test))
summary(diabetes)
# Train-test split
library(caTools)
set.seed(111)
diabetes$split = sample.split(diabetes$positive.test, SplitRatio = 0.7)
diabetes_train = subset(diabetes, split == T)
diabetes_test = subset(diabetes, split == F)
# Excluding split columns
diabetes_train = diabetes_train[-10]
diabetes_test = diabetes_test[-10]
# Writing CSV for train and test
write.table(diabetes_train, sep = ',', file = './datasets/Diabetes_train.csv', row.names = F)
write.table(diabetes_test, sep = ',', file = './datasets/Diabetes_test.csv', row.names = F)
# Loading neural net packages
# install.packages(c('nnet', 'neuralnet', 'pnn', 'RSNNS', 'NeuralNetTools'))
library(nnet)
library(neuralnet)
library(grnn)
library(RSNNS)
library(NeuralNetTools)
# Building the neural net model
diabetes_nnet = nnet(positive.test ~ ., data = diabetes_train,
size = 8, maxit = 10000, decay = 0.0001)
summary(diabetes_nnet)
# Prediction and confusion matrix
pred = predict(diabetes_nnet, newdata = diabetes_test, type = 'class')
cm = table(true = diabetes_test$positive.test, predicted = pred)
library(caret)
cm1 = confusionMatrix(cm)
cm1
plotnet(diabetes_nnet)
diabetes_train$positive.test = as.numeric(as.character(diabetes_train$positive.test))
diabetes_test$positive.test = as.numeric(as.character(diabetes_test$positive.test))
summary(diabetes_train)
summary(diabetes_test)
diabetes_gnet = learn(set = diabetes_train, variable.column = length(diabetes_train))
diabetes_gnet = smooth(diabetes_gnet, sigma = 0.5)
diabetes_test$predict = -1
diabetes_testsub = diabetes_test[, 1:8]
vec = as.matrix(diabetes_testsub[1, ])
res = guess(diabetes_gnet, vec)
for(i in 1:nrow(diabetes_testsub)) {
vec = as.matrix(diabetes_testsub[i, ])
res = guess(diabetes_gnet, vec)
if(anyNA(res)) {
cat("Entry ",i," Generated NaN result!\n")
} else{
diabetes_test$predict[i] = res
}
}
View(diabetes_test)
View(diabetes_testsub)
diabetes_test$predictclass = round(diabetes_test$predict)
View(diabetes_test)
vec = as.matrix(diabetes_testsub[7, ])
res = guess(diabetes_gnet, vec)
vec = as.matrix(as.numeric(diabetes_testsub[7, ]))
res = guess(diabetes_gnet, vec)
vec
vec = as.matrix(diabetes_testsub[7, ])
vec
typeof(vec)
typeof(vec[1])
typeof(vec[2])
typeof(vec[3])
typeof(vec[4])
typeof(vec[5])
typeof(vec[6])
typeof(vec[7])
typeof(vec[8])
typeof(vec[9])
typeof(vec[10])
res = guess(diabetes_gnet, vec)
vec = as.matrix(diabetes_testsub[6, ])
res = guess(diabetes_gnet, vec)
vec = as.matrix(diabetes_testsub[5, ])
res = guess(diabetes_gnet, vec)
vec = as.matrix(diabetes_testsub[4, ])
res = guess(diabetes_gnet, vec)
vec = as.matrix(diabetes_testsub[7, ])
res = guess(diabetes_gnet, vec)
vec = as.numeric(diabetes_testsub[7, ])
vec
res = guess(diabetes_gnet, vec)
vec = as.matrix(diabetes_testsub[7, ])
res = guess(diabetes_gnet, vec)
library(ISLR)
library(e1071)
library(caret)
library(caTools)
data(Default)
summary(Default)
library(ISLR)
library(e1071)
library(caret)
library(caTools)
data(Default)
summary(Default)
set.seed(111)
split = sample.split(Default$default, SplitRatio = 0.8)
train = subset(Default, split == T)
test = subset(Default, split == F)
# train and test sets with balance and income only
train_bi = train[, c('default', 'balance', 'income')]
test_bi = test[, c('default', 'balance', 'income')]
# train and test sets with student and balance only
train_bs = train[, c('default', 'balance', 'student')]
test_bs = test[, c('default', 'balance', 'student')]
View(train)
set.seed(111)
split = sample.split(Default$default, SplitRatio = 0.8)
train = subset(Default, split == T)
test = subset(Default, split == F)
# train and test sets with balance and income only
train_bi = train[, c('default', 'balance', 'income')]
test_bi = test[, c('default', 'balance', 'income')]
# train and test sets with student and balance only
train_bs = train[, c('default', 'balance', 'student')]
test_bs = test[, c('default', 'balance', 'student')]
# train and test sets with student and balance only
train_is = train[, c('default', 'income', 'student')]
test_is = test[, c('default', 'income', 'student')]
svm_bi1 = svm(default ~ .,
data = train_bi,
kernel = 'radial',
gamma = 1,
cost = 1)
summary(svm_bi1)
set.seed(111)
tune_out_bi1 = tune(svm,
default ~ .,
data = train_bi,
kernel = 'radial',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_bi1)
bestmod_bi1 = tune_out_bi1$best.model
summary(bestmod_bi1)
# CM on Test Set
newpred_bi_test1 = predict(bestmod_bi1, test_bi)
confusionMatrix(table(prediction = newpred_bi_test1,
actual = test_bi$default))
svm_bi2 = svm(default ~ .,
data = train_bi,
kernel = 'sigmoid',
gamma = 1,
cost = 1)
summary(svm_bi2)
set.seed(111)
tune_out_bi2 = tune(svm,
default ~ .,
data = train_bi,
kernel = 'sigmoid',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_bi2)
bestmod_bi2 = tune_out_bi2$best.model
summary(bestmod_bi2)
# CM on Test Set
newpred_bi_test2 = predict(bestmod_bi2, test_bi)
confusionMatrix(table(prediction = newpred_bi_test2,
actual = test_bi$default))
svm_bs1 = svm(default ~ .,
data = train_bs,
kernel = 'radial',
gamma = 1,
cost = 1)
summary(svm_bs1)
set.seed(111)
tune_out_bs1 = tune(svm,
default ~ .,
data = train_bs,
kernel = 'radial',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_bs1)
bestmod_bs1 = tune_out_bs1$best.model
summary(bestmod_bs1)
# CM on Test Set
newpred_bs_test1 = predict(bestmod_bs1, test_bs)
confusionMatrix(table(prediction = newpred_bs_test1,
actual = test_bs$default))
svm_bs2 = svm(default ~ .,
data = train_bs,
kernel = 'sigmoid',
gamma = 1,
cost = 1)
summary(svm_bs2)
set.seed(111)
tune_out_bs2 = tune(svm,
default ~ .,
data = train_bs,
kernel = 'sigmoid',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_bs2)
bestmod_bs2 = tune_out_bs2$best.model
summary(bestmod_bs2)
# CM on Test Set
newpred_bs_test2 = predict(bestmod_bs2, test_bs)
confusionMatrix(table(prediction = newpred_bs_test2,
actual = test_bs$default))
svm_is1 = svm(default ~ .,
data = train_is,
kernel = 'radial',
gamma = 1,
cost = 1)
summary(svm_is1)
set.seed(111)
tune_out_is1 = tune(svm,
default ~ .,
data = train_is,
kernel = 'radial',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_is1)
bestmod_is1 = tune_out_is1$best.model
summary(bestmod_is1)
# CM on Test Set
newpred_is_test1 = predict(bestmod_is1, test_is)
confusionMatrix(table(prediction = newpred_is1_test1,
actual = test_is$default))
# CM on Test Set
newpred_is_test1 = predict(bestmod_is1, test_is)
>>>>>>> Stashed changes
confusionMatrix(table(prediction = newpred_is_test1,
actual = test_is$default))
svm_is2 = svm(default ~ .,
data = train_is,
kernel = 'sigmoid',
gamma = 1,
cost = 1)
summary(svm_is2)
set.seed(111)
tune_out_is2 = tune(svm,
default ~ .,
data = train_is,
kernel = 'sigmoid',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_is2)
bestmod_is2 = tune_out_is2$best.model
summary(bestmod_is2)
# CM on Test Set
newpred_is_test2 = predict(bestmod_is2, test_is)
confusionMatrix(table(prediction = newpred_is_test2,
actual = test_is$default))
svm_all1 = svm(default ~ .,
data = train,
kernel = 'radial',
gamma = 1,
cost = 1)
summary(svm_all1)
set.seed(111)
tune_out_all1 = tune(svm,
default ~ .,
data = train,
kernel = 'radial',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_all1)
bestmod_all1 = tune_out_all1$best.model
summary(bestmod_all1)
# CM on Test Set
newpred_all_test1 = predict(bestmod_all1, test)
confusionMatrix(table(prediction = newpred_all_test1,
actual = test$default))
svm_all2 = svm(default ~ .,
data = train,
kernel = 'sigmoid',
gamma = 1,
cost = 1)
summary(svm_all2)
set.seed(111)
tune_out_all2 = tune(svm,
default ~ .,
data = train,
kernel = 'sigmoid',
ranges = list(cost = c(0.1, 1, 10, 100, 1000),
gamma = c(0.5, 1, 2, 3, 4)),
tunecontrol = tune.control(sampling = 'cross',
cross = 5))
summary(tune_out_all2)
bestmod_all2 = tune_out_all2$best.model
summary(bestmod_all2)
# CM on Test Set
newpred_all_test2 = predict(bestmod_all2, test)
confusionMatrix(table(prediction = newpred_all_test2,
actual = test$default))
# Data import
wine = read.csv('./datasets/winequality-white.csv')
summary(wine)
# Train-test split
set.seed(111)
library(caTools)
wine$split = sample.split(wine$quality, SplitRatio = 0.7)
wine_train = subset(wine, split == T)
wine_test = subset(wine, split == F)
# Excluding split columns
wine_train = wine_train[-13]
wine_test = wine_test[-13]
# Writing CSV for train and test
write.table(wine_train, sep = ',', file = './datasets/winequality_train.csv', row.names = F)
write.table(wine_test, sep = ',', file = './datasets/winequality_test.csv', row.names = F)
install.packages('qrnn')
library(qrnn)
library(qrnn)
wine_qrnn = qrnn.fit(x = wine_train[-12],
y = wine_train[12],
n.hidden = 8,
iter.max = 5000)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = wine_train[12],
n.hidden = 8,
iter.max = 5000)
library(qrnn)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 8,
iter.max = 5000)
library(qrnn)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 8,
iter.max = 5000,
Th = linear)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 8,
iter.max = 5000,
Th = linear)
wine_pred_qrnn = predict(wine_qrnn, newdata = wine_test)
wine_pred_qrnn = qrnn.predict(wine_qrnn, newdata = wine_test)
wine_pred_qrnn = qrnn.predict(x = as.matrix(wine_test[-12]), parms = wine_qrnn)
wine_pred_qrnn = as.numeric(round(wine_pred_brnn))
wine_pred_qrnn = as.numeric(round(wine_pred_qrnn))
model_values3 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_qrnn)
defaultSummary(model_values3)
library(caret)
<<<<<<< Updated upstream
cm_nn = confusionMatrix(table(true = diabetes_test$positive.test, predicted = test_pred))
cm_nn
diabetes_pnet = learn(set = diabetes_train, category.column = length(diabetes_train))
diabetes_pnet = smooth(diabetes_pnet, sigma = .5)
diabetes_test$predict = -1
diabetes_testsub = diabetes_test[, 1:8]
vec = as.matrix(diabetes_testsub[7, ])
res = guess(diabetes_gnet, vec)
res = guess(diabetes_pnet, vec)
vec = as.matrix(diabetes_testsub[1, ])
res = guess(diabetes_pnet, vec)
res$category
res = res$category
vec = as.matrix(diabetes_testsub[7, ])
res = guess(diabetes_pnet, vec)
res = res$category
vec = as.matrix(diabetes_testsub[7, ])
res = guess(diabetes_pnet, vec)
res = ifelse(is.na(res$category), NA, res$category)
res = ifelse(is.na(res), NA, res$category)
vec = as.matrix(diabetes_testsub[6, ])
res = guess(diabetes_pnet, vec)
res = ifelse(is.na(res), NA, res$category)
res = guess(diabetes_pnet, vec)
res = ifelse(is.na(res), NA, res$category)
res
res = guess(diabetes_pnet, vec)
res$category
is.na(res)
vec = as.matrix(diabetes_testsub[6, ])
res = guess(diabetes_pnet, vec)
res = ifelse(anyNA(res), NA, res$category)
for(i in 1:nrow(diabetes_testsub)) {
vec = as.matrix(diabetes_testsub[i, ])
res = guess(diabetes_pnet, vec)
res = ifelse(anyNA(res), NA, res$category)
if(anyNA(res)) {
cat("Entry ",i," Generated NaN result!\n")
} else{
diabetes_test$predict[i] = res
}
}
diabetes_pnet = smooth(diabetes_pnet, sigma = 1)
for(i in 1:nrow(diabetes_testsub)) {
vec = as.matrix(diabetes_testsub[i, ])
res = guess(diabetes_pnet, vec)
res = ifelse(anyNA(res), NA, res$category)
if(anyNA(res)) {
cat("Entry ",i," Generated NaN result!\n")
} else{
diabetes_test$predict[i] = res
}
}
for(i in 1:nrow(diabetes_testsub)) {
vec = as.matrix(diabetes_testsub[i, ])
res = guess(diabetes_pnet, vec)
res = ifelse(anyNA(res), NA, res$category)
if(anyNA(res)) {
cat("Entry ",i," Generated NaN result!\n")
} else{
diabetes_test$predict[i] = res
}
}
diabetes_pnet = smooth(diabetes_pnet, sigma = 1.4)
for(i in 1:nrow(diabetes_testsub)) {
vec = as.matrix(diabetes_testsub[i, ])
res = guess(diabetes_pnet, vec)
res = ifelse(anyNA(res), NA, res$category)
if(anyNA(res)) {
cat("Entry ",i," Generated NaN result!\n")
library(knitr)
purl("ci1_assignment.Rmd", output="ci1_assignment.R", documentation=2)
q()
# Data import
diabetes = read.csv('./datasets/Diabetes.csv', header = F)
colnames(diabetes) = c('no.of.times.preg', 'plasma.glucose.conc', 'diastolic.pressure',
'triceps.skin.fold.thick', 'serum.insulin', 'bmi', 'diab.pedigree.func',
'age', 'positive.test')
# Factorizing class variable
diabetes$positive.test = as.factor(as.character(diabetes$positive.test))
summary(diabetes)
# Train-test split
library(caTools)
set.seed(111)
diabetes$split = sample.split(diabetes$positive.test, SplitRatio = 0.7)
diabetes_train = subset(diabetes, split == T)
diabetes_test = subset(diabetes, split == F)
# Excluding split columns
diabetes_train = diabetes_train[-10]
diabetes_test = diabetes_test[-10]
# Writing CSV for train and test
write.table(diabetes_train, sep = ',', file = './datasets/Diabetes_train.csv', row.names = F)
write.table(diabetes_test, sep = ',', file = './datasets/Diabetes_test.csv', row.names = F)
# Building the neural net model
library(nnet)
diabetes_nnet = nnet(positive.test ~ ., data = diabetes_train,
size = 8, maxit = 10000, decay = 0.0001)
summary(diabetes_nnet)
require(RCurl)
root.url<-'https://gist.githubusercontent.com/fawda123'
raw.fun<-paste(
root.url,
'5086859/raw/cc1544804d5027d82b70e74b83b3941cd2184354/nnet_plot_fun.r',
sep='/'
)
script<-getURL(raw.fun, ssl.verifypeer = FALSE)
eval(parse(text = script))
rm('script','raw.fun')
plot(diabetes_nnet)
# Prediction and confusion matrix
test_pred = predict(diabetes_nnet, newdata = diabetes_test, type = 'class')
library(caret)
cm_nn = confusionMatrix(table(true = diabetes_test$positive.test, predicted = test_pred))
cm_nn
diabetes_pcann = pcaNNet(positive.test ~ ., data = diabetes_train,
size = 8, maxit = 10000, decay = 0.0001)
summary(diabetes_pcann)
# Prediction and confusion matrix
test_pred_pcann = predict(diabetes_pcann, newdata = diabetes_test, type = 'class')
cm_pcann = confusionMatrix(table(true = diabetes_test$positive.test, predicted = test_pred_pcann))
cm_pcann
set.seed(111)
control1 = trainControl(method = 'repeatedcv', number = 10, repeats = 3)
# NN Fits
fit.nn = train(positive.test ~ ., data = diabetes_train, method = 'nnet', metric = 'Accuracy', trControl = control1)
fit.pcann = train(positive.test ~ ., data = diabetes_train, method = 'pcaNNet', metric = 'Accuracy', trControl = control1)
# Result summary
result1 = resamples(list(nn = fit.nn, pcann = fit.pcann))
summary(result1)
dotplot(result1)
# Data import
wine = read.csv('./datasets/winequality-white.csv')
head(wine)
# Train-test split
set.seed(111)
wine$split = sample.split(wine$quality, SplitRatio = 0.7)
wine_train = subset(wine, split == T)
wine_test = subset(wine, split == F)
#normalize <- function(x) {
#    return ((x - min(x)) / (max(x) - min(x)))
#}
#wine_train <- as.data.frame(lapply(wine_train, normalize))
#wine_test <- as.data.frame(lapply(wine_test, normalize))
# Excluding split columns
wine_train = wine_train[-13]
wine_test = wine_test[-13]
# Writing CSV for train and test
write.table(wine_train, sep = ',', file = './datasets/winequality_train.csv', row.names = F)
write.table(wine_test, sep = ',', file = './datasets/winequality_test.csv', row.names = F)
wine_nnet = nnet(quality ~ ., data = wine_train,
size = 10, maxit = 1000, decay = 0.0001, linout = T)
plot(wine_nnet)
wine_pred_nnet = predict(wine_nnet, newdata = wine_test)
wine_pred_nnet = as.numeric(round(wine_pred_nnet))
model_values0 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_nnet)
defaultSummary(model_values0)
# Building the RBF
library(RSNNS)
wine_rbfnet = rbf(x = wine_train[-12],
y = wine_train[12],
size = c(8),
maxit = 1000,
linOut = T)
summary(wine_rbfnet)
# Prediction
rbf_pred = predict(wine_rbfnet, newdata = wine_test[-12])
rbf_pred = as.numeric(round(rbf_pred))
model_values1 = data.frame(obs = as.numeric(wine_test$quality), pred = rbf_pred)
defaultSummary(model_values1)
library(brnn)
wine_brnn = brnn(quality ~ ., data = wine_train,
neurons = 8,
epochs = 1000)
wine_brnn
# Prediction
wine_pred_brnn = predict(wine_brnn, newdata = wine_test)
wine_pred_brnn = as.numeric(round(wine_pred_brnn))
# l = sort(union(wine_pred_brnn, wine_test$quality))
# wine_pred_brnn = factor(as.character(wine_pred_brnn), levels = l)
# Confusion Matrix
# cm_table = table(wine_pred_brnn, factor(as.character(wine_test$quality), levels = l))
# cm_brnn = confusionMatrix(cm_table)
# cm_brnn
model_values2 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_brnn)
defaultSummary(model_values2)
library(caret)
library(caretEnsemble)
set.seed(111)
control1 = trainControl(method = 'cv', number = 10, repeats = 3,savePredictions=TRUE)
# NN Fits
#fit.nn = train(quality~ ., data = wine_train, method = 'rbf', trControl = control1)
#fit.pcann = train(quality ~ ., data = wine_train, method = 'brnn', metric = 'Accuracy', trControl = control1)
algorithmList <- c( 'rbfDDA','DENFIS') #, 'brnn'
#models <- caretList(quality~., data=wine_train, trControl=control1, methodList=algorithmList)
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train,
trControl=control2,
methodList=c("rbfDDA", "nnet")
)
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train,
trControl=control2,
methodList=c("nnet", "dnn")
)
result1 <- resamples(models)
result1 <- resamples(model_list)
summary(result1)
dotplot(result1)
greedy_ensemble <- caretEnsemble(
model_list,
metric="ROC",
trControl=trainControl(
number=10,
summaryFunction=twoClassSummary,
classProbs=TRUE
))
model_preds <- lapply(model_list, predict, newdata=wine_test, type="prob")
predict(model_list,wine_test)
greedy_ensemble <- caretEnsemble(
model_list,
metric="ROC",
trControl=trainControl(
number=2,
summaryFunction=twoClassSummary,
classProbs=TRUE
))
greedy_ensemble <- caretEnsemble(
model_list,
metric="ROC",
trControl=trainControl(
number=2,
classProbs=TRUE
))
greedy_ensemble <- caretEnsemble(
model_list,
metric="ROC",
trControl=trainControl(
number=10,
classProbs=TRUE
))
greedy_ensemble <- caretEnsemble(
model_list,
metric="ROC",
trControl=control2)
greedy_ensemble <- caretEnsemble(
model_list,
trControl=control2)
summary(greedy_ensemble)
model_list <- caretList(
quality~., data=wine_train,
trControl=control2,
methodList=c("svmRadial", "dnn")
)
wine_train$quality <- as.factor(wine_train$quality)
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train,
trControl=control2,
methodList=c("svmRadial", "dnn")
)
wine_train2 <- wine_train
names(wine_train2)
names(wine_train2) <- c('X1','X2','X3','X4','X5','X6','X7','X8','X9','X10','X11','Y')
View(wine_train2)
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train2$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train2,
trControl=control2,
methodList=c("svmRadial", "dnn")
)
names(wine_train2) <- c('X1','X2','X3','X4','X5','X6','X7','X8','X9','X10','X11','quality')
wine_train$quality <- as.factor(wine_train$quality)
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train2$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train2,
trControl=control2,
methodList=c("svmRadial", "dnn")
)
wine_train$quality <- as.numeric(wine_train$quality)
wine_train2$quality <- as.numeric(wine_train2$quality)
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train2$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train2,
trControl=control2,
methodList=c("svmRadial", "dnn")
)
greedy_ensemble <- caretEnsemble(
model_list,
trControl=control2)
summary(greedy_ensemble)
result1 <- resamples(model_list)
summary(result1)
dotplot(result1)
model_preds <- lapply(model_list, predict, newdata=wine_test, type="prob")
control2 <- trainControl(
method="boot",
number=25,
savePredictions="final",
classProbs=TRUE,
index=createResample(wine_train$quality, 25)
)
model_list <- caretList(
quality~., data=wine_train,
trControl=control2,
methodList=c("svmRadial", "dnn")
)
greedy_ensemble <- caretEnsemble(
model_list,
trControl=control2)
summary(greedy_ensemble)
model_preds <- lapply(model_list, predict, newdata=wine_test, type="prob")
model_preds <- lapply(model_list, predict, newdata=wine_test)
model_preds <- lapply(model_list, predict, newdata=wine_test[-12])
enseble_predict <- predict(greedy_ensemble,wine_test[-12] )
enseble_predict <-round (predict(greedy_ensemble,wine_test[-12] ))
model_preds[0]
model_preds[1]
model_preds[2]
round(model_preds[2])
round(model_preds["svmRadial"])
model_preds["svmRadial"]
dff <- do.call(rbind.data.frame, model_preds)
View(dff)
dff <- data.frame(matrix(unlist(model_preds))
#names(getModelInfo())
dff <- data.frame(matrix(unlist(model_preds)))
dff <- data.frame(matrix(unlist(model_preds)))
View(dff)
dff <- as.data.frame(model_preds["svmRadial"])
View(dff)
dff$dnn <- model_preds["dnn"]
View(dff)
model_preds["dnn"][1]
dff$dnn <- model_preds["dnn"][1]
View(dff)
model_preds["dnn"][1][1]
dff$dnn <- model_preds["dnn"][1][1]
View(dff)
unlist(model_preds["dnn"])
unlist(model_preds["dnn"])[1,1]
unlist(model_preds["dnn"])[1]
unlist(model_preds["dnn"])[0]
unlist(model_preds["dnn"])[2]
as.matrix(unlist(model_preds["dnn"]))
as.matrix(unlist(model_preds["dnn"]))[,1]
as.matrix(unlist(model_preds["dnn"]))[2]
as.matrix(unlist(model_preds["dnn"]))[1]
as.matrix(unlist(model_preds["dnn"]))
dff$dnn <- as.matrix(unlist(model_preds["dnn"]))
View(dff)
dff <- do.call(rbind, lapply(model_preds, data.frame, stringsAsFactors=FALSE))
View(dff)
model_preds
dff <- as.data.frame(predic(model_list$dnn, newdata=wine_test[-12]))
dff <- as.data.frame(predict(model_list$dnn, newdata=wine_test[-12]))
View(dff)
dff <- as.data.frame(predict(model_list$dnn, newdata=wine_test[-12]), names=c("dnn"))
View(dff)
dff <- as.data.frame(predict(model_list$dnn, newdata=wine_test[-12]), names=c("dnn"))
View(dff)
dff <- as.data.frame(predict(model_list$dnn, newdata=wine_test[-12]))
View(dff)
names(dff)<- c("dnn")
View(dff)
dff$svm <- predict(model_list$dnn, newdata=wine_test[-12])
View(dff)
dff$svm <- round(predict(model_list$dnn, newdata=wine_test[-12]))
View(dff)
model_preds <- lapply(model_list, predict, newdata=wine_test[-12])
enseble_predict <-round (predict(greedy_ensemble,wine_test[-12] ))
model_preds["dnn"]
model_preds["svmRadial"]
=======
defaultSummary(model_values3)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 6,
iter.max = 10000,
Th = linear)
# Prediction
wine_pred_qrnn = qrnn.predict(x = as.matrix(wine_test[-12]), parms = wine_qrnn)
wine_pred_qrnn = as.numeric(round(wine_pred_qrnn))
model_values3 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_qrnn)
library(caret)
defaultSummary(model_values3)
library(qrnn)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 8,
iter.max = 10000,
Th = linear)
# Prediction
wine_pred_qrnn = qrnn.predict(x = as.matrix(wine_test[-12]), parms = wine_qrnn)
wine_pred_qrnn = as.numeric(round(wine_pred_qrnn))
model_values3 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_qrnn)
library(caret)
defaultSummary(model_values3)
library(qrnn)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 6,
iter.max = 10000,
Th = linear)
# Prediction
wine_pred_qrnn = qrnn.predict(x = as.matrix(wine_test[-12]), parms = wine_qrnn)
wine_pred_qrnn = as.numeric(round(wine_pred_qrnn))
model_values3 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_qrnn)
library(caret)
defaultSummary(model_values3)
library(qrnn)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 6,
iter.max = 5000,
Th = linear)
# Prediction
wine_pred_qrnn = qrnn.predict(x = as.matrix(wine_test[-12]), parms = wine_qrnn)
wine_pred_qrnn = as.numeric(round(wine_pred_qrnn))
model_values3 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_qrnn)
library(caret)
defaultSummary(model_values3)
library(qrnn)
wine_qrnn = qrnn.fit(x = as.matrix(wine_train[-12]),
y = as.matrix(wine_train[12]),
n.hidden = 10,
iter.max = 10000,
Th = linear)
# Prediction
wine_pred_qrnn = qrnn.predict(x = as.matrix(wine_test[-12]), parms = wine_qrnn)
wine_pred_qrnn = as.numeric(round(wine_pred_qrnn))
model_values3 = data.frame(obs = as.numeric(wine_test$quality), pred = wine_pred_qrnn)
library(caret)
defaultSummary(model_values3)
wine = read.csv('./datasets/winequality-white.csv')
wine = read.csv('./datasets/winequality-white.csv')
install.packages('frbs')
library(frbs)
wine = read.csv('./datasets/winequality-white.csv')
wine = data.frame(scale(wine))
set.seed(111)
wine$split = sample.split(wine$quality, SplitRatio = 0.7)
wine_train = subset(wine, split == T)
wine_test = subset(wine, split == F)
# Excluding split columns
wine_train = wine_train[-13]
wine_test = wine_test[-13]
set.seed(111)
library(caTools)
wine$split = sample.split(wine$quality, SplitRatio = 0.7)
wine_train = subset(wine, split == T)
wine_test = subset(wine, split == F)
# Excluding split columns
wine_train = wine_train[-13]
wine_test = wine_test[-13]
wine = read.csv('./datasets/winequality-white.csv')
setwd('~/Data/ebac-neuralnets')
wine = read.csv('./datasets/winequality-white.csv')
wine = data.frame(scale(wine))
set.seed(111)
library(caTools)
wine$split = sample.split(wine$quality, SplitRatio = 0.7)
wine_train = subset(wine, split == T)
wine_test = subset(wine, split == F)
# Excluding split columns
wine_train = wine_train[-13]
wine_test = wine_test[-13]
library(caret)
library(caretEnsemble)
set.seed(111)
control1 = trainControl(method = 'cv', number = 10, repeats = 3, savePredictions=TRUE)
library(RSNNS)
algorithmList <- c( 'rbfDDA', 'DENFIS') #, 'brnn'
models <- caretList(quality~., data=wine_train, trControl=control1, methodList=algorithmList)
algorithmList <- c( 'rbfDDA', 'brnn') #, 'brnn'
models <- caretList(quality~., data=wine_train, trControl=control1, methodList=algorithmList)
sporesult1 <- resamples(models)
sporesult1
summary(result1)
summary(sporesult1)
algorithmList <- c( 'gbm', 'nnet') #, 'brnn'
models <- caretList(quality~., data=wine_train, trControl=control1, methodList=algorithmList)
source('~/Data/ebac-neuralnets/ci1_assignment.R', echo=TRUE)
summary(sporesult1)
>>>>>>> Stashed changes
